<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>IELTS start/stop Index Checker</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1730;
      --panel2:#121c3a;
      --text:#e8ecff;
      --muted:#aab3d6;
      --border:rgba(255,255,255,.12);
      --accent:#7aa2ff;
      --good:#4ade80;
      --warn:#fbbf24;
      --bad:#fb7185;
      --hl: rgba(122,162,255,.35);
      --hl2: rgba(74,222,128,.25);
      --shadow: 0 12px 40px rgba(0,0,0,.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:var(--sans); background:linear-gradient(180deg, var(--bg), #070a14);
      color:var(--text);
    }
    header{
      padding:16px 18px; border-bottom:1px solid var(--border);
      position:sticky; top:0; background:rgba(11,16,32,.9); backdrop-filter: blur(10px);
      z-index:5;
    }
    header h1{margin:0; font-size:16px; font-weight:700; letter-spacing:.2px}
    header .sub{margin-top:6px; font-size:12px; color:var(--muted)}
    main{
      display:grid; grid-template-columns: 420px 1fr;
      gap:14px; padding:14px;
      min-height: calc(100vh - 68px);
    }
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--border);
      border-radius:14px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card h2{
      margin:0; padding:12px 14px; font-size:13px; letter-spacing:.2px;
      border-bottom:1px solid var(--border);
      background:rgba(255,255,255,.04);
    }
    .card .body{padding:12px 14px}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    label{font-size:12px; color:var(--muted)}
    select, input[type="number"], input[type="text"]{
      width:100%; padding:10px 10px; border-radius:10px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.25);
      color:var(--text);
      outline:none;
    }
    input[type="file"]{
      width:100%;
      padding:10px 10px;
      border-radius:10px;
      border:1px dashed var(--border);
      background:rgba(0,0,0,.18);
      color:var(--muted);
    }
    button{
      appearance:none; border:1px solid var(--border);
      background:rgba(122,162,255,.18);
      color:var(--text);
      padding:10px 12px; border-radius:10px;
      cursor:pointer;
      transition: transform .04s ease, background .12s ease;
      font-weight:600;
    }
    button:hover{background:rgba(122,162,255,.25)}
    button:active{transform: translateY(1px)}
    .pill{
      display:inline-flex; gap:8px; align-items:center;
      padding:7px 10px; border-radius:999px;
      border:1px solid var(--border); background:rgba(0,0,0,.20);
      font-size:12px; color:var(--muted);
    }
    .pill b{color:var(--text); font-weight:700}
    .status.good{color:var(--good)}
    .status.warn{color:var(--warn)}
    .status.bad{color:var(--bad)}
    .q-list{
      max-height: 62vh;
      overflow:auto;
      padding-right:4px;
    }
    .q{
      border:1px solid var(--border);
      background:rgba(0,0,0,.18);
      border-radius:12px;
      padding:10px 10px;
      margin-bottom:10px;
    }
    .q .top{display:flex; justify-content:space-between; gap:10px; align-items:flex-start}
    .q .num{font-weight:800; font-size:12px}
    .q .type{font-size:11px; color:var(--muted)}
    .q .prompt{margin:8px 0 10px; font-size:12px; color:var(--text); line-height:1.35}
    .q .meta{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
    .q .meta code{font-family:var(--mono); font-size:11px; color:var(--muted)}
    .q .controls{
      display:grid; grid-template-columns: 1fr 1fr;
      gap:8px; margin-top:10px;
    }
    .q .controls label{display:block; margin-bottom:6px}
    .q .controls input{font-family:var(--mono)}
    .q .actions{margin-top:10px; display:flex; gap:8px; flex-wrap:wrap}
    .q .preview{
      margin-top:10px;
      font-family:var(--mono);
      font-size:11px;
      color:var(--muted);
      white-space:pre-wrap;
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px;
      background:rgba(0,0,0,.20);
    }

    .passage-wrap{
      height: calc(100vh - 110px);
      overflow:auto;
      padding:14px;
    }
    .passage-title{
      display:flex; justify-content:space-between; align-items:flex-start;
      gap:14px; padding:12px 14px;
      border-bottom:1px solid var(--border);
      background:rgba(255,255,255,.04);
    }
    .passage-title h2{margin:0; font-size:14px}
    .passage-title .small{font-size:12px; color:var(--muted); margin-top:6px}
    .passage{
      font-family:var(--sans);
      font-size:14px;
      line-height:1.65;
      white-space:pre-wrap;
      word-break:break-word;
    }
    mark{
      background:var(--hl);
      color:var(--text);
      padding:0 2px;
      border-radius:4px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.12);
    }
    mark.active{
      outline: 2px solid rgba(251,191,36,.8);
      background: rgba(251,191,36,.22);
    }
    mark.answer{
      background: var(--hl2);
    }
    .help{
      font-size:12px; color:var(--muted); line-height:1.45;
    }
    .help code{font-family:var(--mono); color:var(--text)}
    .split{
      display:grid; grid-template-columns: 1fr 1fr; gap:10px;
    }
    .divider{height:1px; background:var(--border); margin:12px 0}
  </style>
</head>
<body>
  <header>
    <h1>IELTS startIndex / stopIndex Checker</h1>
    <div class="sub">
      Load your JSON → select a passage → click a question → verify highlights in the passage text.
      Indexes are treated as character offsets into <code>passage.text</code> (0-based, stopIndex is exclusive).
    </div>
  </header>

  <main>
    <section class="card">
      <h2>Controls</h2>
      <div class="body">
        <div class="row">
          <label style="width:100%">JSON file</label>
          <input id="file" type="file" accept=".json,application/json" />
        </div>

        <div class="divider"></div>

        <div class="split">
          <div>
            <label>Passage</label>
            <select id="passageSelect"></select>
          </div>
          <div>
            <label>Group filter</label>
            <select id="groupSelect">
              <option value="">All groups</option>
            </select>
          </div>
        </div>

        <div class="divider"></div>

        <div class="row">
          <button id="clearActive" type="button">Clear active highlight</button>
          <button id="exportEdits" type="button">Export edits (JSON)</button>
        </div>

        <p class="help" style="margin-top:12px">
          Tips:
          <br/>• If you see a highlight shifted by 1–2 characters, check for spaces/newlines in the source passage.
          <br/>• The preview box shows the substring for your current indexes.
          <br/>• Use “Export edits” to download a patched JSON (only indexes you changed are updated).
        </p>

        <div class="divider"></div>

        <div class="row">
          <span class="pill">Questions loaded: <b id="qCount">0</b></span>
          <span class="pill">Highlights: <b id="hlCount">0</b></span>
          <span class="pill">Active: <b id="activeLabel">None</b></span>
        </div>

        <div class="divider"></div>

        <h2 style="margin:0 0 10px 0; font-size:13px; border:none; background:transparent; padding:0">Questions</h2>
        <div id="qList" class="q-list"></div>
      </div>
    </section>

    <section class="card">
      <div class="passage-title">
        <div>
          <h2 id="passageTitle">No passage loaded</h2>
          <div class="small" id="passageMeta"></div>
        </div>
        <div class="pill">
          Passage length: <b id="passageLen">0</b>
        </div>
      </div>
      <div class="passage-wrap" id="passageWrap">
        <div class="passage" id="passage"></div>
      </div>
    </section>
  </main>

<script>
(() => {
  // ===== Utilities =====
  const el = (id) => document.getElementById(id);

  const escapeHtml = (s) => s
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");

  const clamp = (n, min, max) => Math.max(min, Math.min(max, n));

  const downloadText = (filename, text, mime="application/json") => {
    const blob = new Blob([text], {type: mime});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(a.href), 2500);
  };

  // ===== State =====
  let raw = null;          // Loaded JSON object
  let passage = null;      // Current passage object
  let edits = new Map();   // item_id -> {start_index, stop_index}
  let activeItemId = null;

  // Flatten items for current passage (with group metadata)
  function collectItems(p) {
    const out = [];
    if (!p?.groups) return out;

    for (const g of p.groups) {
      const gId = g.group_id || "";
      const gType = g.type || "";
      const items = g.items || [];
      for (const it of items) {
        const ans = it.answer || {};
        // Only items with indexes are highlightable; but still list all for completeness.
        out.push({
          item_id: it.item_id,
          number: it.number,
          prompt: it.prompt || "",
          group_id: gId,
          group_type: gType,
          answer_type: ans.type || "",
          answer_value: ans.value ?? "",
          start_index: (typeof ans.start_index === "number") ? ans.start_index : null,
          stop_index: (typeof ans.stop_index === "number") ? ans.stop_index : null,
        });
      }
    }
    return out.sort((a,b) => (a.number ?? 0) - (b.number ?? 0));
  }

  function getEditedOrOriginal(item) {
    const e = edits.get(item.item_id);
    return {
      start: (e && typeof e.start_index === "number") ? e.start_index : item.start_index,
      stop:  (e && typeof e.stop_index  === "number") ? e.stop_index  : item.stop_index,
    };
  }

  // ===== Highlight rendering =====
  function renderPassageWithHighlights(items) {
    const text = passage?.text ?? "";
    el("passageLen").textContent = String(text.length);

    // Build segments: list of {start, stop, item_id}
    const segs = [];
    for (const it of items) {
      const {start, stop} = getEditedOrOriginal(it);
      if (typeof start !== "number" || typeof stop !== "number") continue;
      if (!Number.isFinite(start) || !Number.isFinite(stop)) continue;
      if (start < 0 || stop <= start || start >= text.length) continue;
      segs.push({start, stop: Math.min(stop, text.length), item_id: it.item_id});
    }
    // Sort by start
    segs.sort((a,b) => a.start - b.start || a.stop - b.stop);

    // Merge overlaps by splitting into non-overlapping marks; simplest: stack marks by order.
    // We will render sequentially and if overlap occurs, we still render nested spans using data attributes.
    // To keep it stable, we will cut the text at all boundary points.
    const boundaries = new Set([0, text.length]);
    for (const s of segs) { boundaries.add(s.start); boundaries.add(s.stop); }
    const points = Array.from(boundaries).sort((a,b)=>a-b);

    const parts = [];
    let hlCount = 0;

    for (let i=0; i<points.length-1; i++) {
      const a = points[i], b = points[i+1];
      const chunk = text.slice(a,b);
      const covering = segs.filter(s => s.start <= a && s.stop >= b);
      if (covering.length === 0) {
        parts.push(escapeHtml(chunk));
      } else {
        // if multiple, pick the first for id (still show tooltip listing all)
        const ids = covering.map(x => x.item_id);
        const primary = ids[0];
        const isActive = (primary === activeItemId);
        const title = ids.join(", ");
        const cls = "answer" + (isActive ? " active" : "");
        parts.push(`<mark class="${cls}" data-item="${escapeHtml(primary)}" title="${escapeHtml(title)}">${escapeHtml(chunk)}</mark>`);
        hlCount++;
      }
    }

    el("hlCount").textContent = String(hlCount);
    el("passage").innerHTML = parts.join("");
  }

  function scrollToActiveMark() {
    if (!activeItemId) return;
    const wrap = el("passageWrap");
    const mark = wrap.querySelector(`mark[data-item="${CSS.escape(activeItemId)}"]`);
    if (!mark) return;
    mark.scrollIntoView({behavior:"smooth", block:"center"});
  }

  // ===== Question list rendering =====
  function indexStatus(start, stop, textLen) {
    if (typeof start !== "number" || typeof stop !== "number") return {cls:"warn", label:"missing"};
    if (start < 0 || stop < 0) return {cls:"bad", label:"negative"};
    if (stop <= start) return {cls:"bad", label:"stop<=start"};
    if (start >= textLen) return {cls:"bad", label:"start>=len"};
    if (stop > textLen) return {cls:"warn", label:"stop>len"};
    return {cls:"good", label:"ok"};
  }

  function buildQuestionCard(item, textLen) {
    const {start, stop} = getEditedOrOriginal(item);
    const st = indexStatus(start, stop, textLen);
    const preview = (typeof start === "number" && typeof stop === "number")
      ? (passage.text.slice(clamp(start,0,textLen), clamp(stop,0,textLen)))
      : "";

    const container = document.createElement("div");
    container.className = "q";
    container.dataset.itemId = item.item_id;

    const top = document.createElement("div");
    top.className = "top";
    top.innerHTML = `
      <div>
        <div class="num">Q${item.number ?? ""} <span class="type">(${escapeHtml(item.group_type)} / ${escapeHtml(item.answer_type)})</span></div>
        <div class="meta">
          <code>${escapeHtml(item.item_id)}</code>
          <span class="status ${st.cls}">${st.label}</span>
        </div>
      </div>
      <div class="pill"><b>${escapeHtml(item.group_id || "")}</b></div>
    `;

    const prompt = document.createElement("div");
    prompt.className = "prompt";
    prompt.textContent = item.prompt || "(no prompt)";

    const controls = document.createElement("div");
    controls.className = "controls";
    controls.innerHTML = `
      <div>
        <label>start_index</label>
        <input type="number" step="1" inputmode="numeric" value="${(typeof start==="number")?start:""}" placeholder="(none)" />
      </div>
      <div>
        <label>stop_index</label>
        <input type="number" step="1" inputmode="numeric" value="${(typeof stop==="number")?stop:""}" placeholder="(none)" />
      </div>
    `;

    const actions = document.createElement("div");
    actions.className = "actions";
    actions.innerHTML = `
      <button type="button" data-action="focus">Highlight</button>
      <button type="button" data-action="copy">Copy substring</button>
      <button type="button" data-action="reset">Reset</button>
    `;

    const previewBox = document.createElement("div");
    previewBox.className = "preview";
    previewBox.textContent = preview ? preview : "(no preview)";

    // Wire events
    const [startInput, stopInput] = Array.from(controls.querySelectorAll("input"));

    const updateFromInputs = () => {
      const s = startInput.value === "" ? null : Number(startInput.value);
      const t = stopInput.value === "" ? null : Number(stopInput.value);

      // Save edit only if numbers; else clear edit
      if (typeof s === "number" && Number.isFinite(s) && typeof t === "number" && Number.isFinite(t)) {
        edits.set(item.item_id, {start_index: s, stop_index: t});
      } else {
        edits.delete(item.item_id);
      }

      // Update status & preview
      const {start: ns, stop: nt} = getEditedOrOriginal(item);
      const st2 = indexStatus(ns, nt, textLen);
      container.querySelector(".status").className = `status ${st2.cls}`;
      container.querySelector(".status").textContent = st2.label;

      const pv = (typeof ns === "number" && typeof nt === "number") ? passage.text.slice(clamp(ns,0,textLen), clamp(nt,0,textLen)) : "";
      previewBox.textContent = pv ? pv : "(no preview)";

      // Re-render passage highlights
      const items = getVisibleItems();
      renderPassageWithHighlights(items);

      // If this is active, keep it in view
      if (activeItemId === item.item_id) scrollToActiveMark();
    };

    startInput.addEventListener("input", updateFromInputs);
    stopInput.addEventListener("input", updateFromInputs);

    actions.addEventListener("click", (e) => {
      const btn = e.target.closest("button");
      if (!btn) return;
      const action = btn.dataset.action;
      if (action === "focus") {
        setActive(item.item_id);
      } else if (action === "copy") {
        const {start: ns, stop: nt} = getEditedOrOriginal(item);
        const pv = (typeof ns === "number" && typeof nt === "number") ? passage.text.slice(clamp(ns,0,textLen), clamp(nt,0,textLen)) : "";
        navigator.clipboard?.writeText(pv || "");
        btn.textContent = "Copied";
        setTimeout(()=>btn.textContent="Copy substring", 800);
      } else if (action === "reset") {
        edits.delete(item.item_id);
        // restore inputs from original
        startInput.value = (typeof item.start_index === "number") ? item.start_index : "";
        stopInput.value  = (typeof item.stop_index  === "number") ? item.stop_index  : "";
        updateFromInputs();
      }
    });

    container.addEventListener("dblclick", () => setActive(item.item_id));

    container.appendChild(top);
    container.appendChild(prompt);
    container.appendChild(controls);
    container.appendChild(actions);
    container.appendChild(previewBox);
    return container;
  }

  let cachedItems = [];
  function renderQuestions() {
    if (!passage) return;
    const items = collectItems(passage);
    cachedItems = items;
    el("qCount").textContent = String(items.length);

    // Group filter options
    const groupSel = el("groupSelect");
    const prev = groupSel.value;
    const groups = Array.from(new Set(items.map(x => x.group_id))).filter(Boolean);
    groupSel.innerHTML = `<option value="">All groups</option>` + groups.map(g => `<option value="${escapeHtml(g)}">${escapeHtml(g)}</option>`).join("");
    if (groups.includes(prev)) groupSel.value = prev;

    const list = el("qList");
    list.innerHTML = "";
    const visible = getVisibleItems(items);
    const textLen = passage.text.length;

    for (const it of visible) {
      list.appendChild(buildQuestionCard(it, textLen));
    }
  }

  function getVisibleItems(itemsOpt) {
    const items = itemsOpt || cachedItems;
    const g = el("groupSelect").value;
    if (!g) return items;
    return items.filter(x => x.group_id === g);
  }

  function setActive(itemId) {
    activeItemId = itemId;
    el("activeLabel").textContent = itemId ? itemId : "None";

    // Update passage rendering to set active class
    renderPassageWithHighlights(getVisibleItems());

    // Scroll to active
    scrollToActiveMark();

    // Visually emphasize card
    const list = el("qList");
    list.querySelectorAll(".q").forEach(q => {
      q.style.outline = (q.dataset.itemId === itemId) ? "2px solid rgba(251,191,36,.45)" : "none";
    });
    const card = list.querySelector(`.q[data-item-id="${CSS.escape(itemId)}"]`);
    if (card) card.scrollIntoView({behavior:"smooth", block:"nearest"});
  }

  // ===== Data loading =====
  function setPassageByIndex(idx) {
    const p = raw?.passages?.[idx];
    passage = p || null;
    activeItemId = null;
    el("activeLabel").textContent = "None";

    if (!passage) {
      el("passageTitle").textContent = "No passage loaded";
      el("passageMeta").textContent = "";
      el("passage").textContent = "";
      el("passageLen").textContent = "0";
      el("qList").innerHTML = "";
      el("qCount").textContent = "0";
      el("hlCount").textContent = "0";
      return;
    }

    el("passageTitle").textContent = `${passage.title || "Untitled"} (${passage.passage_id || ""})`;
    const groups = (passage.groups || []).length;
    el("passageMeta").textContent = `Groups: ${groups}`;

    edits = new Map(); // reset edits when switching passage (easy + safe)

    renderQuestions();
    renderPassageWithHighlights(getVisibleItems());
    el("passageWrap").scrollTop = 0;
  }

  function populatePassageSelect() {
    const sel = el("passageSelect");
    sel.innerHTML = "";
    const ps = raw?.passages || [];
    ps.forEach((p, i) => {
      const opt = document.createElement("option");
      opt.value = String(i);
      opt.textContent = `${p.passage_id || "?"}: ${p.title || "Untitled"}`;
      sel.appendChild(opt);
    });
    sel.value = "0";
    setPassageByIndex(0);
  }

  // ===== Export patched JSON =====
  function exportEdits() {
    if (!raw || !passage) return;

    // Create deep-ish copy (stringify/parse ensures clean)
    const patched = JSON.parse(JSON.stringify(raw));

    // Apply edits only for current passage
    const pIdx = Number(el("passageSelect").value);
    const p = patched.passages[pIdx];
    const items = collectItems(p);

    const mapById = new Map(items.map(i => [i.item_id, i]));
    for (const [itemId, val] of edits.entries()) {
      const original = mapById.get(itemId);
      if (!original) continue;
      // mutate patched structure: find the item by traversal (small scale; acceptable)
      for (const g of p.groups || []) {
        for (const it of g.items || []) {
          if (it.item_id === itemId) {
            it.answer = it.answer || {};
            it.answer.start_index = val.start_index;
            it.answer.stop_index = val.stop_index;
          }
        }
      }
    }

    const outName = `patched_${(passage.passage_id || "passage")}.json`;
    downloadText(outName, JSON.stringify(patched, null, 2));
  }

  // ===== Event wiring =====
  el("file").addEventListener("change", async (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    const txt = await f.text();
    try{
      raw = JSON.parse(txt);
      populatePassageSelect();
    } catch(err){
      alert("Invalid JSON file.");
      console.error(err);
    }
  });

  el("passageSelect").addEventListener("change", () => {
    setPassageByIndex(Number(el("passageSelect").value));
  });

  el("groupSelect").addEventListener("change", () => {
    renderQuestions();
    renderPassageWithHighlights(getVisibleItems());
  });

  el("clearActive").addEventListener("click", () => {
    activeItemId = null;
    el("activeLabel").textContent = "None";
    renderPassageWithHighlights(getVisibleItems());
    // remove card outlines
    el("qList").querySelectorAll(".q").forEach(q => q.style.outline = "none");
  });

  el("exportEdits").addEventListener("click", exportEdits);

  // Click on highlight in passage to activate corresponding question (primary id)
  el("passageWrap").addEventListener("click", (e) => {
    const m = e.target.closest("mark[data-item]");
    if (!m) return;
    const id = m.dataset.item;
    if (!id) return;
    setActive(id);
  });

  // Optional: preload from embedded sample if present (window.__SAMPLE__)
  if (window.__SAMPLE__) {
    raw = window.__SAMPLE__;
    populatePassageSelect();
  }
})();
</script>
</body>
</html>
